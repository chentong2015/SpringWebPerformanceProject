TODO. 分页优化
1. 偏移量很大会导致查询性能下降: 避免使用偏移，记录上次查询的最大ID
   where id > ? order by id fetch first ? rows only

2. 如果需要显示"共N条记录"总数 select count(id)

TOTO. 分页查询会自动生成两个Query, 一个查询数据，一个统计总数
Hibernate: select ue1_0.id,ue1_0.email,ue1_0.name from t_users ue1_0 order by ue1_0.id offset ? rows fetch first ? rows only
Hibernate: select count(ue1_0.id) from t_users ue1_0

   EntityManagerFactory emf = entityManager.getEntityManagerFactory();
   ExecutorService executor = Executors.newSingleThreadExecutor();
   Future<Long> countFuture = executor.submit(() -> {
       try (EntityManager em = emf.createEntityManager()) {
           CriteriaQuery<Long> countQuery = getDraftKzRecordsCountQuery(em, draftKzRecordsSpecification);
           TypedQuery<Long> countTypedQuery = em.createQuery(countQuery);
           return countTypedQuery.getSingleResult(); // 统计结果不会被Lazy加载，保证使用安全
       }
   });
   CriteriaQuery<KzRecord> draftKzRecordsCriteriaQuery = getDraftKzRecordsQuery(entityManager, draftKzRecordsSpecification, page.getSort());
   TypedQuery<KzRecord> draftKzRecordsQuery = getPageableCriteriaQuery(entityManager, draftKzRecordsCriteriaQuery, page);
   List<KzRecord> recordList = draftKzRecordsQuery.getResultList();
   Long count = countFuture.get(60, TimeUnit.SECONDS); // 异步执行Count统计，避免重复执行
   return new PageImpl<>(recordList, page, count);